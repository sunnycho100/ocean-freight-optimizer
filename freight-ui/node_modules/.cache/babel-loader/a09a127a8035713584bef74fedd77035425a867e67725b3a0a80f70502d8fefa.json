{"ast":null,"code":"/**\r\n * Utility functions for generating Google Maps Directions URLs\r\n * No API key required - uses the public Google Maps web interface\r\n */\n\n/**\r\n * Cleans a location string by removing internal region codes\r\n * (e.g., \"BREMERHAVEN, HB, GERMANY\" -> \"BREMERHAVEN, GERMANY\")\r\n */\nexport function cleanLocationString(location) {\n  if (!location) return '';\n\n  // Split by commas and trim\n  const parts = location.split(',').map(s => s.trim());\n\n  // Common region codes to filter out (state/province abbreviations)\n  const regionCodes = ['HB', 'NW', 'BY', 'BW', 'HE', 'RP', 'BB',\n  // German states\n  'DROME', 'FRANCE' // Already has country\n  ];\n\n  // Filter out single/two-letter codes and known region abbreviations\n  const filtered = parts.filter(part => {\n    // Keep if it's a longer name or if it looks like a country\n    if (part.length > 3) return true;\n    // Remove if it's a known region code\n    if (regionCodes.includes(part.toUpperCase())) return false;\n    // Keep otherwise\n    return true;\n  });\n  return filtered.join(', ');\n}\n\n/**\r\n * Generates a Google Maps Directions URL for opening in a new tab\r\n * @param origin - Starting location (e.g., \"Le Havre, France\")\r\n * @param destination - Ending location (e.g., \"Bremerhaven, Germany\")\r\n * @param travelMode - Optional travel mode: driving (default), walking, bicycling, transit\r\n * @returns Full Google Maps Directions URL\r\n */\nexport function generateGoogleMapsDirectionsUrl(origin, destination, travelMode = 'driving') {\n  const cleanOrigin = cleanLocationString(origin);\n  const cleanDestination = cleanLocationString(destination);\n  const baseUrl = 'https://www.google.com/maps/dir/?api=1';\n  const params = new URLSearchParams({\n    origin: cleanOrigin,\n    destination: cleanDestination,\n    travelmode: travelMode\n  });\n  return `${baseUrl}&${params.toString()}`;\n}\n\n/**\r\n * Rough distance estimation between two locations based on city/country names\r\n * This is a simplified approach that categorizes routes by typical distances\r\n */\nfunction estimateDistance(origin, destination) {\n  const origLower = origin.toLowerCase();\n  const destLower = destination.toLowerCase();\n\n  // Extract country names\n  const getCountry = location => {\n    const lower = location.toLowerCase();\n    if (lower.includes('germany')) return 'germany';\n    if (lower.includes('france')) return 'france';\n    if (lower.includes('netherlands')) return 'netherlands';\n    if (lower.includes('belgium')) return 'belgium';\n    if (lower.includes('italy')) return 'italy';\n    if (lower.includes('austria')) return 'austria';\n    if (lower.includes('poland')) return 'poland';\n    if (lower.includes('hungary')) return 'hungary';\n    return '';\n  };\n  const originCountry = getCountry(origLower);\n  const destCountry = getCountry(destLower);\n\n  // Same city or very close (within same region)\n  if (origLower.includes(destLower.split(',')[0]) || destLower.includes(origLower.split(',')[0])) {\n    return 30; // ~30km\n  }\n\n  // Germany internal routes\n  if (originCountry === 'germany' && destCountry === 'germany') {\n    // Major port cities to inland destinations\n    if ((origLower.includes('hamburg') || origLower.includes('bremerhaven')) && (destLower.includes('muenster') || destLower.includes('dortmund'))) {\n      return 200; // ~200km\n    }\n    if ((origLower.includes('hamburg') || origLower.includes('bremerhaven')) && (destLower.includes('fuerth') || destLower.includes('forchheim'))) {\n      return 450; // ~450km\n    }\n    return 300; // Default Germany internal\n  }\n\n  // Belgium/Netherlands to Germany\n  if ((originCountry === 'belgium' || originCountry === 'netherlands') && destCountry === 'germany') {\n    return 350; // ~350km average\n  }\n\n  // France routes\n  if (originCountry === 'france' || destCountry === 'france') {\n    if (destCountry === 'germany' || originCountry === 'germany') {\n      return 600; // ~600km\n    }\n  }\n\n  // Italy routes\n  if (originCountry === 'italy' || destCountry === 'italy') {\n    return 900; // ~900km\n  }\n\n  // Austria routes\n  if (originCountry === 'austria' || destCountry === 'austria') {\n    return 700; // ~700km\n  }\n\n  // Poland routes\n  if (originCountry === 'poland' || destCountry === 'poland') {\n    return 800; // ~800km\n  }\n\n  // Hungary (very distant)\n  if (originCountry === 'hungary' || destCountry === 'hungary') {\n    return 1200; // ~1200km\n  }\n\n  // Default for unknown routes\n  return 500;\n}\n\n/**\r\n * Estimates appropriate zoom level based on distance between locations\r\n * @param origin - Starting location\r\n * @param destination - Ending location\r\n * @returns Zoom level (higher = more zoomed in)\r\n * \r\n * Zoom levels based on distance:\r\n * - 0-70 KM: zoom 10 (most zoomed in - increased by 2)\r\n * - 71-200 KM: zoom 7 (zoomed in)\r\n * - 201-600 KM: zoom 6 (normal)\r\n * - 601-1099 KM: zoom 5 (zoomed out)\r\n * - 1100+ KM: zoom 4 (most zoomed out)\r\n */\nfunction estimateZoomLevel(origin, destination) {\n  const distance = estimateDistance(origin, destination);\n  if (distance <= 70) {\n    return 10; // 0-70 km: zoom in twice more from previous level 8 (6+4)\n  } else if (distance <= 200) {\n    return 7; // 71-200 km: zoom in once from base (6+1)\n  } else if (distance <= 600) {\n    return 6; // 201-600 km: normal zoom (base)\n  } else if (distance <= 1099) {\n    return 5; // 601-1099 km: zoom out once (6-1)\n  } else {\n    return 4; // 1100+ km: zoom out twice (6-2)\n  }\n}\n\n/**\r\n * Generates a Google Maps embed URL for an inline iframe preview (no API key required)\r\n * Uses the public web interface with output=embed. Automatically adjusts zoom based on\r\n * estimated distance (same country = closer = more zoom, different countries = farther = less zoom).\r\n */\nexport function generateGoogleMapsEmbedUrl(origin, destination, travelMode = 'driving') {\n  var _modeToFlag$travelMod;\n  const cleanOrigin = cleanLocationString(origin);\n  const cleanDestination = cleanLocationString(destination);\n\n  // Estimate zoom based on location proximity\n  const zoom = estimateZoomLevel(origin, destination);\n\n  // dirflg mapping mirrors Google Maps query params\n  const modeToFlag = {\n    driving: 'd',\n    walking: 'w',\n    bicycling: 'b',\n    transit: 'r'\n  };\n  const params = new URLSearchParams({\n    saddr: cleanOrigin,\n    daddr: cleanDestination,\n    dirflg: (_modeToFlag$travelMod = modeToFlag[travelMode]) !== null && _modeToFlag$travelMod !== void 0 ? _modeToFlag$travelMod : 'd',\n    output: 'embed',\n    z: String(zoom)\n  });\n  return `https://www.google.com/maps?${params.toString()}`;\n}\n\n/**\r\n * Simple test function to verify URL generation\r\n */\nexport function testGoogleMapsUrl() {\n  const testCases = [{\n    origin: 'Le Havre, France',\n    destination: 'Bremerhaven, Germany',\n    expectedOrigin: 'Le Havre, France',\n    expectedDest: 'Bremerhaven, Germany'\n  }, {\n    origin: 'BREMERHAVEN, HB, GERMANY',\n    destination: 'VALENCE, DROME, FRANCE',\n    expectedOrigin: 'BREMERHAVEN, GERMANY',\n    expectedDest: 'VALENCE, FRANCE'\n  }, {\n    origin: 'MUENSTER, NW, GERMANY',\n    destination: 'ROTTERDAM, NETHERLANDS',\n    expectedOrigin: 'MUENSTER, GERMANY',\n    expectedDest: 'ROTTERDAM, NETHERLANDS'\n  }];\n  console.log('=== Google Maps URL Generation Tests ===\\n');\n  testCases.forEach((test, index) => {\n    const url = generateGoogleMapsDirectionsUrl(test.origin, test.destination);\n    const cleanOrigin = cleanLocationString(test.origin);\n    const cleanDest = cleanLocationString(test.destination);\n    const pass = cleanOrigin === test.expectedOrigin && cleanDest === test.expectedDest;\n    console.log(`Test ${index + 1}: ${pass ? '✓ PASS' : '✗ FAIL'}`);\n    console.log(`  Origin: \"${test.origin}\" → \"${cleanOrigin}\"`);\n    console.log(`  Expected: \"${test.expectedOrigin}\"`);\n    console.log(`  Destination: \"${test.destination}\" → \"${cleanDest}\"`);\n    console.log(`  Expected: \"${test.expectedDest}\"`);\n    console.log(`  URL: ${url}`);\n    console.log('');\n  });\n}\n\n// Uncomment to run tests in browser console:\n// testGoogleMapsUrl();","map":{"version":3,"names":["cleanLocationString","location","parts","split","map","s","trim","regionCodes","filtered","filter","part","length","includes","toUpperCase","join","generateGoogleMapsDirectionsUrl","origin","destination","travelMode","cleanOrigin","cleanDestination","baseUrl","params","URLSearchParams","travelmode","toString","estimateDistance","origLower","toLowerCase","destLower","getCountry","lower","originCountry","destCountry","estimateZoomLevel","distance","generateGoogleMapsEmbedUrl","_modeToFlag$travelMod","zoom","modeToFlag","driving","walking","bicycling","transit","saddr","daddr","dirflg","output","z","String","testGoogleMapsUrl","testCases","expectedOrigin","expectedDest","console","log","forEach","test","index","url","cleanDest","pass"],"sources":["C:/Users/PNS/Desktop/automation/freight-ui/src/utils/googleMapsHelper.ts"],"sourcesContent":["/**\r\n * Utility functions for generating Google Maps Directions URLs\r\n * No API key required - uses the public Google Maps web interface\r\n */\r\n\r\n/**\r\n * Cleans a location string by removing internal region codes\r\n * (e.g., \"BREMERHAVEN, HB, GERMANY\" -> \"BREMERHAVEN, GERMANY\")\r\n */\r\nexport function cleanLocationString(location: string): string {\r\n  if (!location) return '';\r\n  \r\n  // Split by commas and trim\r\n  const parts = location.split(',').map(s => s.trim());\r\n  \r\n  // Common region codes to filter out (state/province abbreviations)\r\n  const regionCodes = [\r\n    'HB', 'NW', 'BY', 'BW', 'HE', 'RP', 'BB', // German states\r\n    'DROME', 'FRANCE', // Already has country\r\n  ];\r\n  \r\n  // Filter out single/two-letter codes and known region abbreviations\r\n  const filtered = parts.filter(part => {\r\n    // Keep if it's a longer name or if it looks like a country\r\n    if (part.length > 3) return true;\r\n    // Remove if it's a known region code\r\n    if (regionCodes.includes(part.toUpperCase())) return false;\r\n    // Keep otherwise\r\n    return true;\r\n  });\r\n  \r\n  return filtered.join(', ');\r\n}\r\n\r\n/**\r\n * Generates a Google Maps Directions URL for opening in a new tab\r\n * @param origin - Starting location (e.g., \"Le Havre, France\")\r\n * @param destination - Ending location (e.g., \"Bremerhaven, Germany\")\r\n * @param travelMode - Optional travel mode: driving (default), walking, bicycling, transit\r\n * @returns Full Google Maps Directions URL\r\n */\r\nexport function generateGoogleMapsDirectionsUrl(\r\n  origin: string,\r\n  destination: string,\r\n  travelMode: 'driving' | 'walking' | 'bicycling' | 'transit' = 'driving'\r\n): string {\r\n  const cleanOrigin = cleanLocationString(origin);\r\n  const cleanDestination = cleanLocationString(destination);\r\n  \r\n  const baseUrl = 'https://www.google.com/maps/dir/?api=1';\r\n  const params = new URLSearchParams({\r\n    origin: cleanOrigin,\r\n    destination: cleanDestination,\r\n    travelmode: travelMode,\r\n  });\r\n  \r\n  return `${baseUrl}&${params.toString()}`;\r\n}\r\n\r\n/**\r\n * Rough distance estimation between two locations based on city/country names\r\n * This is a simplified approach that categorizes routes by typical distances\r\n */\r\nfunction estimateDistance(origin: string, destination: string): number {\r\n  const origLower = origin.toLowerCase();\r\n  const destLower = destination.toLowerCase();\r\n  \r\n  // Extract country names\r\n  const getCountry = (location: string): string => {\r\n    const lower = location.toLowerCase();\r\n    if (lower.includes('germany')) return 'germany';\r\n    if (lower.includes('france')) return 'france';\r\n    if (lower.includes('netherlands')) return 'netherlands';\r\n    if (lower.includes('belgium')) return 'belgium';\r\n    if (lower.includes('italy')) return 'italy';\r\n    if (lower.includes('austria')) return 'austria';\r\n    if (lower.includes('poland')) return 'poland';\r\n    if (lower.includes('hungary')) return 'hungary';\r\n    return '';\r\n  };\r\n  \r\n  const originCountry = getCountry(origLower);\r\n  const destCountry = getCountry(destLower);\r\n  \r\n  // Same city or very close (within same region)\r\n  if (origLower.includes(destLower.split(',')[0]) || destLower.includes(origLower.split(',')[0])) {\r\n    return 30; // ~30km\r\n  }\r\n  \r\n  // Germany internal routes\r\n  if (originCountry === 'germany' && destCountry === 'germany') {\r\n    // Major port cities to inland destinations\r\n    if ((origLower.includes('hamburg') || origLower.includes('bremerhaven')) && \r\n        (destLower.includes('muenster') || destLower.includes('dortmund'))) {\r\n      return 200; // ~200km\r\n    }\r\n    if ((origLower.includes('hamburg') || origLower.includes('bremerhaven')) &&\r\n        (destLower.includes('fuerth') || destLower.includes('forchheim'))) {\r\n      return 450; // ~450km\r\n    }\r\n    return 300; // Default Germany internal\r\n  }\r\n  \r\n  // Belgium/Netherlands to Germany\r\n  if ((originCountry === 'belgium' || originCountry === 'netherlands') && destCountry === 'germany') {\r\n    return 350; // ~350km average\r\n  }\r\n  \r\n  // France routes\r\n  if (originCountry === 'france' || destCountry === 'france') {\r\n    if (destCountry === 'germany' || originCountry === 'germany') {\r\n      return 600; // ~600km\r\n    }\r\n  }\r\n  \r\n  // Italy routes\r\n  if (originCountry === 'italy' || destCountry === 'italy') {\r\n    return 900; // ~900km\r\n  }\r\n  \r\n  // Austria routes\r\n  if (originCountry === 'austria' || destCountry === 'austria') {\r\n    return 700; // ~700km\r\n  }\r\n  \r\n  // Poland routes\r\n  if (originCountry === 'poland' || destCountry === 'poland') {\r\n    return 800; // ~800km\r\n  }\r\n  \r\n  // Hungary (very distant)\r\n  if (originCountry === 'hungary' || destCountry === 'hungary') {\r\n    return 1200; // ~1200km\r\n  }\r\n  \r\n  // Default for unknown routes\r\n  return 500;\r\n}\r\n\r\n/**\r\n * Estimates appropriate zoom level based on distance between locations\r\n * @param origin - Starting location\r\n * @param destination - Ending location\r\n * @returns Zoom level (higher = more zoomed in)\r\n * \r\n * Zoom levels based on distance:\r\n * - 0-70 KM: zoom 10 (most zoomed in - increased by 2)\r\n * - 71-200 KM: zoom 7 (zoomed in)\r\n * - 201-600 KM: zoom 6 (normal)\r\n * - 601-1099 KM: zoom 5 (zoomed out)\r\n * - 1100+ KM: zoom 4 (most zoomed out)\r\n */\r\nfunction estimateZoomLevel(origin: string, destination: string): number {\r\n  const distance = estimateDistance(origin, destination);\r\n  \r\n  if (distance <= 70) {\r\n    return 10; // 0-70 km: zoom in twice more from previous level 8 (6+4)\r\n  } else if (distance <= 200) {\r\n    return 7; // 71-200 km: zoom in once from base (6+1)\r\n  } else if (distance <= 600) {\r\n    return 6; // 201-600 km: normal zoom (base)\r\n  } else if (distance <= 1099) {\r\n    return 5; // 601-1099 km: zoom out once (6-1)\r\n  } else {\r\n    return 4; // 1100+ km: zoom out twice (6-2)\r\n  }\r\n}\r\n\r\n/**\r\n * Generates a Google Maps embed URL for an inline iframe preview (no API key required)\r\n * Uses the public web interface with output=embed. Automatically adjusts zoom based on\r\n * estimated distance (same country = closer = more zoom, different countries = farther = less zoom).\r\n */\r\nexport function generateGoogleMapsEmbedUrl(\r\n  origin: string,\r\n  destination: string,\r\n  travelMode: 'driving' | 'walking' | 'bicycling' | 'transit' = 'driving'\r\n): string {\r\n  const cleanOrigin = cleanLocationString(origin);\r\n  const cleanDestination = cleanLocationString(destination);\r\n\r\n  // Estimate zoom based on location proximity\r\n  const zoom = estimateZoomLevel(origin, destination);\r\n\r\n  // dirflg mapping mirrors Google Maps query params\r\n  const modeToFlag: Record<string, string> = {\r\n    driving: 'd',\r\n    walking: 'w',\r\n    bicycling: 'b',\r\n    transit: 'r',\r\n  };\r\n\r\n  const params = new URLSearchParams({\r\n    saddr: cleanOrigin,\r\n    daddr: cleanDestination,\r\n    dirflg: modeToFlag[travelMode] ?? 'd',\r\n    output: 'embed',\r\n    z: String(zoom),\r\n  });\r\n\r\n  return `https://www.google.com/maps?${params.toString()}`;\r\n}\r\n\r\n/**\r\n * Simple test function to verify URL generation\r\n */\r\nexport function testGoogleMapsUrl(): void {\r\n  const testCases = [\r\n    {\r\n      origin: 'Le Havre, France',\r\n      destination: 'Bremerhaven, Germany',\r\n      expectedOrigin: 'Le Havre, France',\r\n      expectedDest: 'Bremerhaven, Germany',\r\n    },\r\n    {\r\n      origin: 'BREMERHAVEN, HB, GERMANY',\r\n      destination: 'VALENCE, DROME, FRANCE',\r\n      expectedOrigin: 'BREMERHAVEN, GERMANY',\r\n      expectedDest: 'VALENCE, FRANCE',\r\n    },\r\n    {\r\n      origin: 'MUENSTER, NW, GERMANY',\r\n      destination: 'ROTTERDAM, NETHERLANDS',\r\n      expectedOrigin: 'MUENSTER, GERMANY',\r\n      expectedDest: 'ROTTERDAM, NETHERLANDS',\r\n    },\r\n  ];\r\n  \r\n  console.log('=== Google Maps URL Generation Tests ===\\n');\r\n  \r\n  testCases.forEach((test, index) => {\r\n    const url = generateGoogleMapsDirectionsUrl(test.origin, test.destination);\r\n    const cleanOrigin = cleanLocationString(test.origin);\r\n    const cleanDest = cleanLocationString(test.destination);\r\n    \r\n    const pass = cleanOrigin === test.expectedOrigin && cleanDest === test.expectedDest;\r\n    \r\n    console.log(`Test ${index + 1}: ${pass ? '✓ PASS' : '✗ FAIL'}`);\r\n    console.log(`  Origin: \"${test.origin}\" → \"${cleanOrigin}\"`);\r\n    console.log(`  Expected: \"${test.expectedOrigin}\"`);\r\n    console.log(`  Destination: \"${test.destination}\" → \"${cleanDest}\"`);\r\n    console.log(`  Expected: \"${test.expectedDest}\"`);\r\n    console.log(`  URL: ${url}`);\r\n    console.log('');\r\n  });\r\n}\r\n\r\n// Uncomment to run tests in browser console:\r\n// testGoogleMapsUrl();\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}